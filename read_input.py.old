#! /usr/bin/env python
from __future__ import print_function, division

def read_mol_input(filename):
    '''Reads a formatted pySCF input file, and
    generates a relevant pySCF Mole object from it.

    Input: the filename of the pySCF input file
    Output: a pySCF Mole object'''

    import input_reader
    from pyscf import gto
    from pyscf.pbc import gto as pbcgto
    import numpy as np

    # initialize reader for a pySCF input
    reader = input_reader.InputReader(comment=['!', '#', '::', '//'],
             case=False, ignoreunknown=True)

    # add atoms block
    atoms = reader.add_block_key('atoms', required=True)
    atoms.add_regex_line('atom',
        '\s*([A-Za-z.]+)\s+(\-?\d+\.?\d*)\s+(\-?\d+.?\d*)\s+(\-?\d+.?\d*)', repeat=True)

    # add simple line keys
    reader.add_line_key('memory', type=(int, float))            # max memory in MB
    reader.add_line_key('unit', default='angstrom')             # coord unit
    reader.add_line_key('basis', default='sto-3g')              # basis
    reader.add_line_key('charge', type=int)                     # molecular charge
    reader.add_line_key('spin', type=int)                       # molecular spin
    reader.add_line_key('verbose', type=(0,1,2,3,4,5,6,7,8,9), default=4) # verbose level

    # add periodic block (optional)
    periodic = reader.add_block_key('periodic', required=False)
    periodic.add_line_key('gs', type=[int, int, int], required=True)
    periodic.add_line_key('dimension', type=(1,2,3), required=True)
    lattice = periodic.add_block_key('lattice', end='subend', required=True)
    lattice.add_regex_line('a', '\s*(\-?\d+\.?\d*)\s+(\-?\d+\.?\d*)\s+(\-?\d+\.?\d*)',
                           repeat=True)

    # read the input filename
    inp  = reader.read_input(filename)

    # initialze pySCF molecule object
    mol = gto.Mole()
    lperiodic = bool(inp.periodic)

    # collect atoms in pyscf format
    mol.atom = []
    ghbasis = []
    for r in inp.atoms.atom:
        if 'ghost.' in r.group(1).lower() or 'gh.' in r.group(1).lower():
            ghbasis.append(r.group(1).split('.')[1])
            rgrp1 = 'ghost:{0}'.format(len(ghbasis))
            mol.atom.append([rgrp1, (float(r.group(2)), float(r.group(3)), float(r.group(4)))])
        else:
            mol.atom.append([r.group(1), (float(r.group(2)), float(r.group(3)), float(r.group(4)))])

    # build dict of basis for each atom
    mol.basis = {}
    nghost = 0
    for i in range(len(mol.atom)):
        if 'ghost' in mol.atom[i][0]:
            mol.basis.update({mol.atom[i][0]: gto.basis.load(inp.basis, ghbasis[nghost])})
            nghost += 1
        else:
            mol.basis.update({mol.atom[i][0]: gto.basis.load(inp.basis, mol.atom[i][0])})

    # build molecule object
    if inp.memory is not None: mol.max_memory = inp.memory
    mol.unit = inp.unit
    if inp.charge is not None: mol.charge = inp.charge
    if inp.spin is not None: mol.spin = inp.spin
    mol.verbose = inp.verbose
    mol.build(dump_input=False)

    # return mole object
    if not lperiodic:
        return mol

    # build cell object
    cell = pbcgto.Cell()
    cell.atom = mol.atom
    cell.basis = mol.basis
    cell.unit = inp.unit
    cell.verbose = inp.verbose
    cell.dimension = inp.periodic.dimension
    if inp.memory is not None: cell.max_memory = inp.memory

    # get lattice constant
    a = inp.periodic.lattice.a
    a = np.array([[a[i].group(1), a[i].group(2), a[i].group(3)]
              for i in range(len(a))], dtype=float)
    conversion = 1.
    if inp.unit in ('angstrom', 'a'): conversion = 1.8897261328856432
    cell.a = a * conversion

    # get gs
    cell.gs = np.array(inp.periodic.gs, dtype=int)

    cell.build(dump_input=False)

    # return cell object
    return cell

def read_scf_input(filename):
    '''Reads a formatted pySCF input file, and
    generates a relevant pySCF SCF object from it.

    Input: filename of pySCF input file
    Output: pySCF SCF object'''

    import input_reader
    from pyscf import gto, scf, dft, cc
    from pyscf.cc import ccsd_t
    from pyscf.pbc import scf as pbcscf, cc as pbccc, dft as pbcdft, df as pbcdf
    from simple_timer import timer

    # initialize timer
    timer = timer()
    timer.start('initialize molecule')

    # first read in the mole object
    mol = read_mol_input(filename)

    # initialize reader for a pySCF input
    reader = input_reader.InputReader(comment=['!', '#', '::', '//'],
             case=False, ignoreunknown=True)

    # add line keys
    reader.add_line_key('method', default='hf')                 # SCF method
    reader.add_line_key('xc', default='lda,vwn')                # XC functional
    reader.add_line_key('conv', type=float, default=1e-8)       # conv_tol
    reader.add_line_key('grad', type=float, default=1e-6)       # conv_tol_grad
    reader.add_line_key('maxiter', type=int, default=50)        # max iterations
    reader.add_line_key('verbose', type=(0,1,2,3,4,5,6,7,8,9), default=4) # verbose level
    reader.add_line_key('guess', type=('minao', 'atom', '1e'), default='atom') # intial density guess
    reader.add_line_key('grid', type=(1,2,3,4,5,6,7,8,9), default=2) # dft numint grid

    # add boolean keys
    reader.add_boolean_key('save')                              # save pySCF object

#    # add periodic block (optional)
    periodic = reader.add_block_key('periodic', required=False)
    periodic.add_line_key('kpoints', type=[int, int, int], required=True)
    periodic.add_line_key('fit', type=('df', 'mdf', 'pwdf', 'fftdf'), default='mdf')

    # read the input filename
    inp  = reader.read_input(filename)
    inp.filename = filename
    lperiodic = bool(inp.periodic)

    # print input file to screen
    if inp.verbose > 0:
        pstr("Input File")
        [print (i[:-1]) for i in open(filename).readlines() if ((i[0] not in ['#', '!'])
            and (i[0:2] not in ['::', '//']))]
        pstr("End Input", addline=False)

    # sort out the method
    inp.method = inp.method.lower()
    timer.end('initialize molecule')

    # get kpoints
    if lperiodic:
        kpts = mol.make_kpts(inp.periodic.kpoints)
        print ('k-points: ', repr(kpts))
        grids = pbcdft.gen_grid.BeckeGrids(mol)
        grids.level = inp.grid
        grids.build()
        if inp.periodic.fit == 'fftdf':
            DF = pbcdf.FFTDF
        elif inp.periodic.fit == 'mdf':
            DF = pbcdf.MDF
        elif inp.periodic.fit == 'pwdf':
            DF = pbcdf.PWDF
        else:
            DF = pbcdf.DF

    # UHF
    if inp.method in ('uhf'):
        timer.start('uhf')
        if lperiodic:
            mSCF = pbcscf.KUHF(mol, kpts)
            mSCF.kpts = kpts
            mSCF.grids = grids
            mSCF.with_df = DF(mol)
            mSCF.with_df.kpts = kpts
        else:
            mSCF = scf.UHF(mol)
        mSCF.conv_tol = inp.conv
        mSCF.conv_tol_grad = inp.grad
        mSCF.max_cycle = inp.maxiter
        mSCF.init_guess = inp.guess
        mSCF.kernel()
        timer.end('uhf')

    # RHF
    elif inp.method in ('rhf', 'hf'):
        timer.start('hf')
        if lperiodic:
            mSCF = pbcscf.KRHF(mol, kpts)
            mSCF.kpts = kpts
            mSCF.grids = grids
            mSCF.with_df = DF(mol)
            mSCF.with_df.kpts = kpts
        else:
            if mol.nelectron%2 == 0:
                mSCF = scf.RHF(mol)
            else:
                mSCF = scf.ROHF(mol)
        mSCF.conv_tol = inp.conv
        mSCF.conv_tol_grad = inp.grad
        mSCF.max_cycle = inp.maxiter
        mSCF.init_guess = inp.guess
        mSCF.kernel()
        timer.end('hf')

    # CCSD
    elif inp.method in ('ccsd', 'ccsd(t)'):
        timer.start('hf')
        if lperiodic:
            tSCF = pbcscf.KRHF(mol, kpts)
            tSCF.kpts = kpts
            tSCF.grids = grids
            tSCF.with_df = DF(mol)
            tSCF.with_df.kpts = kpts
        else:
            tSCF = scf.RHF(mol)
        tSCF.conv_tol = inp.conv
        tSCF.conv_tol_grad = inp.grad
        tSCF.max_cycle = inp.maxiter
        tSCF.init_guess = inp.guess
        ehf = tSCF.kernel()
        timer.end('hf')
        timer.start('ccsd')
        if lperiodic:
            mSCF = pbccc.KCCSD(tSCF)
        else:
            mSCF = cc.RCCSD(tSCF)
        mSCF.max_cycle = inp.maxiter
        eccsd, t1, t2 = mSCF.kernel()
        timer.end('ccsd')

        if inp.method in ('ccsd(t)'):
            timer.start('ccsd(t)')
            eris = mSCF.ao2mo()
            e3 = ccsd_t.kernel(mSCF, eris)
            print ('Total CCSD(T) = {0:20.15f}'.format(ehf + eccsd + e3))
            timer.end('ccsd(t)')

    # UKS
    elif inp.method in ('uks', 'udft'):
        timer.start('uks')
        timer.start('grids')
        grids = dft.gen_grid.Grids(mol)
        grids.level = inp.grid
        grids.build()
        timer.end('grids')
        mSCF = dft.UKS(mol)
        mSCF.grids = grids
        mSCF.xc = inp.xc
        mSCF.conv_tol = inp.conv
        mSCF.conv_tol_grad = inp.grad
        mSCF.max_cycle = inp.maxiter
        mSCF.init_guess = inp.guess
        mSCF.small_rho_cutoff = 1e-20
        mSCF.kernel()
        timer.end('uks')

    # RKS
    elif inp.method in ('rks', 'ks', 'rdft', 'dft'):
        timer.start('ks')
        if lperiodic:
            mSCF = pbcdft.KRKS(mol, kpts)
            mSCF.kpts = kpts
            mSCF.grids = grids
            mSCF.with_df = DF(mol)
            mSCF.with_df.kpts = kpts
        else:
            timer.start('grids')
            grids = dft.gen_grid.Grids(mol)
            grids.level = inp.grid
            grids.build()
            timer.end('grids')
            if mol.nelectron%2 == 0:
                mSCF = dft.RKS(mol)
            else:
                mSCF = dft.ROKS(mol)
            mSCF.grids = grids
        mSCF.xc = inp.xc
        mSCF.conv_tol = inp.conv
        mSCF.conv_tol_grad = inp.grad
        mSCF.max_cycle = inp.maxiter
        mSCF.init_guess = inp.guess
        mSCF.small_rho_cutoff = 1e-20
        mSCF.kernel()
        timer.end('ks')

    else:
        print ('ERROR: Unrecognized method!')

    # save object
    if inp.save:
        timer.start('saving object')
        import pickle
        import dill
        import gzip
        mSCF.stdout = None
        mSCF.mol.stdout = None
        if 'ccsd' not in inp.method:
            mSCF._chkfile.close()
            mSCF._chkfile = None
        else:
            mSCF._scf.stdout = None
            mSCF._scf.mol.stdout = None
            mSCF._scf._chkfile.close()
            mSCF._scf._chkfile = None
        fout = gzip.open(inp.filename[:inp.filename.rfind('.')]+'.gz', 'wb')
        pickle.dump(mSCF, fout)
        fout.close()
        timer.end('saving object')

    timer.close()
    return mSCF

def read_geomopt_input(filename):
    '''Reads a formatted pySCF input file.

    Input: filename of pySCF input file
    Output: options for geometry optimization'''

    import input_reader
    from pyscf import gto, scf, dft, cc
    from pyscf.cc import ccsd_t
    from pyscf.pbc import scf as pbcscf, cc as pbccc, dft as pbcdft, df as pbcdf
    from simple_timer import timer

    # initialize timer
    timer = timer()
    timer.start('initialize molecule')

    # first read in the mole object
    mol = read_mol_input(filename)

    # initialize reader for a pySCF input
    reader = input_reader.InputReader(comment=['!', '#', '::', '//'],
             case=False, ignoreunknown=True)

    # add geomopt block key
    geomopt = reader.add_block_key('geomopt', required=True)
    geomopt.add_line_key('conv', type=float, default=1e-6)      # energy convergence
    geomopt.add_line_key('rconv', type=float, default=1e-2)     # distance convergence
    geomopt.add_line_key('maxiter', type=int, default=50)       # geometry iterations
    geomopt.add_line_key('gradtol', type=float, default=1e-4)   # gradient tolerance

    # add line keys
    reader.add_line_key('method', default='hf')                 # SCF method
    reader.add_line_key('xc', default='lda,vwn')                # XC functional
    reader.add_line_key('conv', type=float, default=1e-8)       # conv_tol
    reader.add_line_key('grad', type=float, default=1e-6)       # conv_tol_grad
    reader.add_line_key('maxiter', type=int, default=50)        # max iterations
    reader.add_line_key('verbose', type=(0,1,2,3,4,5,6,7,8,9), default=4) # verbose level
    reader.add_line_key('guess', type=('minao', 'atom', '1e'), default='atom') # intial density guess
    reader.add_line_key('grid', type=(1,2,3,4,5,6,7,8,9), default=2) # dft numint grid

    # read the input filename
    inp  = reader.read_input(filename)
    inp.filename = filename
    inp.mol = mol

    # print input file to screen
    if inp.verbose > 0:
        pstr("Input File")
        [print (i[:-1]) for i in open(filename).readlines() if ((i[0] not in ['#', '!'])
            and (i[0:2] not in ['::', '//']))]
        pstr("End Input", addline=False)

    # return inp object
    return inp

def pstr(st, delim="=", l=80, fill=True, addline=True):
    '''Print formatted string <st> to output'''
    if addline: print ("")
    if len(st) == 0:
        print (delim*l)
    elif len(st) >= l:
        print (st)
    else:
        l1 = int((l-len(st)-2)/2)
        l2 = int((l-len(st)-2)/2 + (l-len(st)-2)%2)
        if fill:
            print (delim*l1+" "+st+" "+delim*l2)
        else:
            print (delim+" "*l1+st+" "*l2+delim)
